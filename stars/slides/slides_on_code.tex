\documentclass{beamer}
\usetheme{Warsaw}

\usepackage{graphicx}
%\usepackage{minted}
\usepackage{listings}
\usepackage{tikz}
\usetikzlibrary{arrows.meta}

\title[STARS-$\mathcal{H}$]{\underline{S}oftware for \underline{T}esting
\underline{A}ccuracy, \underline{R}eliability and \underline{S}calability of
$\mathcal{H}$ierarchical computations (STARS-$\mathcal{H}$).}
\author{Extreme Computing Research Center}
\institute{King Abdullah University of Science and Technology}
\date{\today}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}{Library design}
\begin{block}{Proposed design:}
Each problem can be worked out with matrices of different format. Each problem
can be approximated in given format differently.
\end{block}
To support such design, STARS-H should have following:
\begin{enumerate}
\item Different \textbf{problems}, defined by corresponding data and kernel
(i.e. spatial statistics, electrostatics, electrodynamics, astrophysics).
\item Different matrix \textbf{formats}: block low-rank, $\mathcal{H}$,
$\mathcal{H}^2$, HOLDR, semi-separable and HSS. Matrix of each problem can have
different partitioning even inside a single format (i.e. different hierarchical
partitioning).
\item \textbf{Approximations} with different accuracy in the same matrix format
of the same problem.
\end{enumerate}
\end{frame}

\begin{frame}{Support for N-dimensional arrays}
\begin{block}{}
For some problems, kernel is not scalar (i.e. astrophysics).
\end{block}
Tensor decomposition techniques required $A = A(i_1, \ldots, i_d)$:
\begin{enumerate}
\item Canonical:\\
$A \approx \sum_{(\alpha_1, \ldots \alpha_d)}
U(i_1, \alpha_1) \cdots U(i_d, \alpha_d),$
\item Tucker:\\
$A \approx \sum_{(\alpha_1, \ldots \alpha_d)}
G(\alpha_1, \ldots \alpha_d) U(i_1, \alpha_1) \cdots U(i_d, \alpha_d),$
\item Tensor-Train:\\
$A \approx U(i_1, \alpha_1) \ldots U(\alpha_k, i_k,
\alpha_{k+1}) \ldots U(\alpha_d, i_d),$
\item Skeleton ($row$ and $col$ are basis rows and columns):
$A(i_1, i_2) = \hat{C}(i_1, \alpha_1)\ 
A(row(\alpha_1), col(\alpha_2)) \ \hat{R}(\alpha_2, i_2),$\\
$A \approx \hat{C}(i_1, \alpha_1) A(row(\alpha_1), i_2,
\ldots, i_{d-1}, col(\alpha_d)) \ \hat{R}(\alpha_d, i_d).$
\end{enumerate}
\end{frame}

\lstset{breakatwhitespace=true,
language=C++,
columns=fullflexible,
keepspaces=true,
breaklines=true,
tabsize=3, 
showstringspaces=false,
extendedchars=true}

\defverbatim[colored]\lst{%
\begin{lstlisting}
typedef struct Array *(*block_kernel)(int nrows, int ncols,
    int *irow, int *icol, void *row_data, void *col_data);

struct Array // N-dimensional array
{
    int ndim; // Number of dimensions of array.
    int *shape; // Shape of array.
    int *stride; // Stride of each dimension
    char order; // C or Fortran order.
    int size; // Number of elements of an array.
    char dtype; // Data type of each element of array.
    size_t nbytes; // Size of buffer in bytes.
    void *buffer; // Buffer, containing array.
};
\end{lstlisting}
}
\begin{frame}{Support N-dimensional arrays}
\lst
\end{frame}

\defverbatim[colored]\lst{%
\begin{lstlisting}
int main(int argc, char **argv)
{
    int n = 16;
    double beta = 0.1, tol = 1e-2;
    STARS_Problem *problem;
    STARS_BLR *format;
    STARS_BLRmatrix *matrix;
    format = STARS_gen_ss_blrformat(n, beta);
    matrix = STARS_blr__compress_algebraic_svd(format, tol);
    STARS_BLRmatrix_info(matrix);
    STARS_BLRmatrix_free(matrix);
    STARS_BLR_info(format);
    STARS_BLR_free(format);
    return 0;
}
\end{lstlisting}
}
\begin{frame}{Spatial Statistics example}
\lst
\end{frame}

\defverbatim[colored]\lst{%
\begin{lstlisting}
struct STARS_Problem
{
    int nrows, ncols; // Number of rows and columns of corresponding matrix.
    char symm; // 'S' if problem is symmetric, and 'N' otherwise.
    char dtype; // Data type (as in LAPACK routines names).
    void *row_data, *col_data; // Pointers to data.
    block_kernel kernel; // Pointer to a kernel.
    char *type; // Name of a problem.
};
\end{lstlisting}
}
\begin{frame}{Problem setting}
\lst
\end{frame}

\defverbatim[colored]\lst{%
\begin{lstlisting}
struct STARS_BLR // Block Low-Rank format
{
    STARS_Problem *problem; // Pointer to a problem.
    char symm; // 'S' if format and problem are symmetric, and 'N' otherwise.
    int nrows, ncols; // Number of rows and columns of corresponding matrix.
    int *row_order, *col_order; // Permutation of rows and columns.
    int nbrows, nbcols; // Number of block rows and block columns.
    int *ibrow_start, *ibcol_start; // Start of each block rows/block column.
    int *ibrow_size, *ibcol_size; // Number of rows/columns of each block row/block column.
};
\end{lstlisting}
}
\begin{frame}{Block Low-Rank format}
\lst
\end{frame}

\defverbatim[colored]\lst{%
\begin{lstlisting}
struct STARS_BLRmatrix // Approximation in block low-rank format.
{
    STARS_Problem *problem; // Pointer to a problem.
    STARS_BLR *format; // Pointer to block low-rank format.
    int bcount; // Number of blocks
    int *bindex; // block row and block column index as a pair of integers (bi, bj)
    int *brank; // Rank of each block or -1 if block os not low-rank.
    Array **U, **V; // Arrays of pointers to low-rank factors U and V of each block.
    Array **A; // Array of pointers to data of full-rank blocks.
};
\end{lstlisting}
}
\begin{frame}{Block Low-Rank approximation}
\lst
\end{frame}

\begin{frame}{Plans for $\mathcal{H}-$ and $\mathcal{H}^2-$ matrices}
\begin{itemize}
\item Problem: interaction of particles; kernel: electrostatics, astrophysics
\item Problem: synthetic with given decay of singular values of blocks,
\item Hierarchical partitioning (oct/quad-tree, inertial bisection),
\item Crossand \emph{maxvol} skeleton approximations,
\item Convertion from $\mathcal{H}$ to $\mathcal{H}^2$ with rank truncation,
\item Multi charge Barnes-Hut method (direct $\mathcal{H}^2$ approximation),
\item Decompression routines for $\mathcal{H}-$ and $\mathcal{H}^2-$ matrices,
\item Batched version of entire library.
\end{itemize}
\end{frame}

\end{document}
